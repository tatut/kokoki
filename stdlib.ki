# Kokoki standard library

: dup2 (a b -- a1 a2 b1 b2)
  swap dup rot dup rot swap dump  ;

# drop next to top element
: nip (a b -- b)
  swap drop ;

# copy next to top element
: over (a b -- a b a)
  swap dup rot swap ;

: -rot (a b c -- c a b)
  rot rot ;

: ?dup (a -- a a) # if a is truthy
  [] copy over apush over apush cond ;

: 2dup (a b -- a b a b)
  over over ;

: 2nip (a b c d -- c d)
  rot drop rot drop ;

### : 2tuck (a b c d -- c d a b c d)
###   2dup [5 move] 4 times ;
###
### : 2over (a b c d -- a b cd a b)
###   [3 pick] 2 times ;
###
### : 2rot (a b c d e f -- c d e f a b)
###   [5 move] 2 times ;
###
### : 2swap (a b c d -- c d a b)
###   [3 move] 2 times ;
###
### : 2drop (a b --)
###   drop drop ;
###
### # Convert string containing digits to an integer number
### : str->int (str -- num)
###   [48 -] each
###   [swap 10 * +] fold ;
###
### # Turn n top items in stack to an array
### # eg. 1 2 2 array => [1 2]
### : array (n-items* n -- arr)
###   [] copy swap [swap apush] swap times reverse ;
###
### # Implement if with the primitive cond
### # use like:
### # 1 2 < ["one is less than two".] if
### : if (bool code -- )
###   swap [] copy swap apush swap apush cond ;
###
### # Like if, but also takes an else block
### : if-else (bool then else -- )
###   swap rot [] copy swap apush swap apush
###   true apush swap apush
###   cond ;
###
### # ch-idx  first index of char in string
### : ch-idx (str ch -- str idx)
###   swap len (str ch len)
###   0 swap
###   [ (ch str idx len -- ch str idx len continue?)
###    [ [2dup =] [2drop -1 0 false ] # at end, not found
###
###      # character found here
###      [2 pick 2 pick aget nip 4 pick = ] false
###
###      # continue to next index
###      true [ swap 1 + swap  true ] ] cond ]
###   while
###   drop rot drop
###   ;
###
###
### # split string at char
### : split-at (str ch -- str1 str2)
###   swap len swap rot ch-idx
###   [ [dup -1 = ] [drop nip ""]
###     true [tuck 0 swap slice
###           2swap 1 + swap 3 move -rot slice nip] ]
###   cond ;
###
### # split string to array of lines
### : lines (str -- arr)
###   [] copy swap
###   [ 10 split-at
###     [ # no more lines (last is empty)
###       [len 0 =] [drop apush false]
###
###       # has more lines
###       true [-rot apush swap true]
###       ] cond
###   ] while ;
###
### : first (arr -- arr item)
###   [ [len 0 = ] nil
###     true [0 aget] ] cond ;
###
### : last (arr -- arr item)
###   [ [ len 0 = ] nil
###     true [len 1 - aget] ] cond ;
###
### : butfirst (arr0 -- arr1)
###   len 1 swap slice nip ;
###
### : butlast (arr0 -- arr1)
###   [ [ len 0 > ] [ len 1 - 0 swap slice nip ] ] cond ;
###
### : triml (str0 -- str1)
###   [ first 32 = [butfirst true] false if-else ] while ;
###
### : trimr (str0 -- str1)
###   [ last 32 = [butlast true] false if-else ] while ;
###
### : trim (str0 -- str1)
###   triml trimr ;
###
### : abs (n0 -- n1)
###   dup 0 < [-1 *] if ;
###
### #: interlave (arr0 arr1 -- arr2)
### #  [] copy
### #  [ rot len 0 > [ first  ] if # take from left list
###
### #
### # [ point x y ] record
### # => defines
### # getters: x? y?
### # setters: x! y!
### # constructors:
### # new-point ( x y -- point )
### # empty-point ( -- point)
### # point? (check if item is a point)