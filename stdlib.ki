# Kokoki standard library

: dup2 (a b -- a1 a2 b1 b2)
  swap dup rot dup rot swap ;

: -rot (a b c -- c a b)
  rot rot ;

: ?dup (a -- a a) # if a is truthy
  dup if dup then ;

: 2dup (a b -- a b a b)
  over over ;

: 2nip (a b c d -- c d)
  rot drop rot drop ;

: each                       (arr0 fn -- arr1)
  over len nip 0             (arr0 fn len idx)
  do
    dup 4 pick swap aget     (arr fn len idx arr item0)
    4 pick call              (arr fn len idx arr item1)
    2 pick swap aset drop    (arr fn len idx)
  loop drop ;

: fold                       (arr0 fn -- val)
  over 0 aget                (arr fn arr init)
  swap len nip 1             (arr fn init len 1)
  do
    dup 5 pick swap aget nip (arr fn init len idx val)
    3 move swap 4 pick call -rot  (arr fn val1 len idx)
  loop nip nip ;

: ?even 2 % 0 = ;
: ?odd 2 % 1 = ;

: filter                     (arr0 fn -- arr1)
  over len nip 0 [] -rot
  do                         (arr0 fn limit idx)
    4 pick over aget nip dup (arr0 fn arr1 limit idx item item)
    5 pick call dump
    if
      3 pick swap apush
    then
    drop
  loop nip nip ;


: 2tuck (a b c d -- c d a b c d)
  2dup 5 move 5 move 5 move 5 move ;

: 2over (a b c d -- a b cd a b)
  3 pick 3 pick ;

: 2rot (a b c d e f -- c d e f a b)
  5 move 5 move ;

: 2swap (a b c d -- c d a b)
  3 move 3 move ;

: 2drop (a b --)
  drop drop ;

: digit (ch -- num) 48 - ;
: join-digits (n0 d -- n1)
   swap 10 * + ;

# Convert string containing digits to an integer number
: str->int (str -- num)
  'digit each
  'join-digits fold ;

# Turn n top items in stack to an array
# eg. 1 2 2 array => [1 2]
: array (n-items* n -- arr)
  0 [] -rot
  do (... arr limit 0)
    2 pick 2 pick 2 pick - 3 + move apush drop
  loop ;


### # ch-idx  first index of char in string
### : ch-idx (str ch -- str idx)
###   swap len (str ch len)
###   0 swap
###   [ (ch str idx len -- ch str idx len continue?)
###    [ [2dup =] [2drop -1 0 false ] # at end, not found
###
###      # character found here
###      [2 pick 2 pick aget nip 4 pick = ] false
###
###      # continue to next index
###      true [ swap 1 + swap  true ] ] cond ]
###   while
###   drop rot drop
###   ;
###
###
### # split string at char
### : split-at (str ch -- str1 str2)
###   swap len swap rot ch-idx
###   [ [dup -1 = ] [drop nip ""]
###     true [tuck 0 swap slice
###           2swap 1 + swap 3 move -rot slice nip] ]
###   cond ;
###
### # split string to array of lines
### : lines (str -- arr)
###   [] copy swap
###   [ 10 split-at
###     [ # no more lines (last is empty)
###       [len 0 =] [drop apush false]
###
###       # has more lines
###       true [-rot apush swap true]
###       ] cond
###   ] while ;
###
### : first (arr -- arr item)
###   [ [len 0 = ] nil
###     true [0 aget] ] cond ;
###
### : last (arr -- arr item)
###   [ [ len 0 = ] nil
###     true [len 1 - aget] ] cond ;
###
### : butfirst (arr0 -- arr1)
###   len 1 swap slice nip ;
###
### : butlast (arr0 -- arr1)
###   [ [ len 0 > ] [ len 1 - 0 swap slice nip ] ] cond ;
###
### : triml (str0 -- str1)
###   [ first 32 = [butfirst true] false if-else ] while ;
###
### : trimr (str0 -- str1)
###   [ last 32 = [butlast true] false if-else ] while ;
###
### : trim (str0 -- str1)
###   triml trimr ;
###
### : abs (n0 -- n1)
###   dup 0 < [-1 *] if ;
###
### #: interlave (arr0 arr1 -- arr2)
### #  [] copy
### #  [ rot len 0 > [ first  ] if # take from left list
###
### #
### # [ point x y ] record
### # => defines
### # getters: x? y?
### # setters: x! y!
### # constructors:
### # new-point ( x y -- point )
### # empty-point ( -- point)
### # point? (check if item is a point)