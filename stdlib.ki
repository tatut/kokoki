# Kokoki standard library

: dup2 (a b -- a1 a2 b1 b2)
  swap dup rot dup rot swap dump  ;

# drop next to top element
: nip (a b -- b)
  swap drop ;

# copy next to top element
: over (a b -- a b a)
  swap dup rot swap ;

: -rot (a b c -- c a b)
  rot rot ;

: ?dup (a -- a a) # if a is truthy
  [] copy over apush over apush cond ;

: 2dup (a b -- a b a b)
  over over ;

: 2nip (a b c d -- c d)
  rot drop rot drop ;

: tuck (a b -- b a b)
  dup -rot ;

: 2tuck (a b c d -- c d a b c d)
  2dup [5 move] 4 times ;

: 2over (a b c d -- a b c d a b)
  [3 pick] 2 times ;

: 2rot (a b c d e f -- c d e f a b)
  [5 move] 2 times ;

: 2swap (a b c d -- c d a b)
  [3 move] 2 times ;

: 2drop (a b --)
  drop drop ;

# "foo,bar" 0 [dup . "idx".] [dup 1 + swap rot len rot dump false] while drop .

# Convert string containing digits to an integer number
: str->int (str -- num)
  [48 -] each
  [swap 10 * +] fold ;

# Turn n top items in stack to an array
# eg. 1 2 2 array => [1 2]
: array (n-items* n -- arr)
  [] copy swap [swap apush] swap times reverse ;

# Implement if with the primitive cond
# use like:
# 1 2 < ["one is less than two".] if
: if (bool code -- )
  swap [] copy swap apush swap apush cond ;

# Like if, but also takes an else block
: if-else (bool then else -- )
  swap rot [] copy swap apush swap apush
  true apush swap apush
  cond ;

# ch-idx  first index of char in string
: ch-idx (str ch -- str idx)
  swap len (str ch len)
  0 swap
  [ (ch str idx len -- ch str idx len continue?)
   [ [2dup =] [2drop -1 0 false ] # at end, not found

     # character found here
     [2 pick 2 pick aget nip 4 pick = ] false

     # continue to next index
     true [ swap 1 + swap  true ] ] cond ]
  while
  drop rot drop
  ;


# split string at char
: split-at (str ch -- str1 str2)
  swap len swap rot ch-idx
  [ [dup -1 = dump ] [drop nip ""]
    true [tuck 0 swap slice
          2swap 1 + swap 3 move -rot slice nip] ]
  cond ;
